#!/usr/bin/env python3
"""
Script automatis√© pour obtenir le badge "Pair Extraordinaire" sur GitHub
Utilise l'API GitHub pour une automatisation compl√®te
"""

import os
import sys
import subprocess
import json
import requests
from datetime import datetime
import tempfile
import shutil

class GitHubPairBadgeAutomator:
    def __init__(self):
        self.repo_url = ""
        self.user_name = ""
        self.user_email = ""
        self.github_token = ""
        self.collaborator_name = "GitHub Assistant"
        self.collaborator_email = "assistant@github.example"
        self.branch_name = f"feature/pair-badge-{int(datetime.now().timestamp())}"
        self.repo_name = ""
        self.repo_owner = ""
        self.working_dir = ""
        
    def print_step(self, message):
        print(f"\033[34m[√âTAPE]\033[0m {message}")
        
    def print_success(self, message):
        print(f"\033[32m[SUCC√àS]\033[0m {message}")
        
    def print_warning(self, message):
        print(f"\033[33m[ATTENTION]\033[0m {message}")
        
    def print_error(self, message):
        print(f"\033[31m[ERREUR]\033[0m {message}")
    
    def setup_config(self):
        """Configuration initiale interactive ou par variables d'environnement"""
        self.print_step("Configuration initiale...")
        
        # R√©cup√©rer les informations
        self.github_token = os.getenv('GITHUB_TOKEN') or input("Token GitHub (optionnel pour repos publics): ").strip()
        self.repo_url = os.getenv('REPO_URL') or input("URL du d√©p√¥t GitHub: ").strip()
        self.user_name = os.getenv('USER_NAME') or input("Votre nom GitHub: ").strip()
        self.user_email = os.getenv('USER_EMAIL') or input("Votre email GitHub: ").strip()
        
        # Extraire owner et repo name de l'URL
        if 'github.com/' in self.repo_url:
            parts = self.repo_url.split('github.com/')[-1].replace('.git', '').split('/')
            self.repo_owner = parts[0]
            self.repo_name = parts[1]
        else:
            raise ValueError("URL de d√©p√¥t GitHub invalide")
            
        self.print_success("Configuration termin√©e")
    
    def run_command(self, command, cwd=None):
        """Ex√©cuter une commande shell"""
        try:
            result = subprocess.run(
                command, 
                shell=True, 
                capture_output=True, 
                text=True, 
                cwd=cwd or self.working_dir
            )
            if result.returncode != 0:
                self.print_error(f"Erreur commande: {result.stderr}")
                return False, result.stderr
            return True, result.stdout
        except Exception as e:
            self.print_error(f"Exception: {str(e)}")
            return False, str(e)
    
    def prepare_repo(self):
        """Cloner ou pr√©parer le d√©p√¥t"""
        self.print_step("Pr√©paration du d√©p√¥t...")
        
        # Cr√©er un r√©pertoire temporaire
        self.working_dir = tempfile.mkdtemp(prefix="github_pair_")
        repo_path = os.path.join(self.working_dir, self.repo_name)
        
        # Cloner le d√©p√¥t
        clone_cmd = f"git clone {self.repo_url} {repo_path}"
        success, output = self.run_command(clone_cmd, self.working_dir)
        
        if not success:
            self.print_error("√âchec du clonage")
            return False
            
        self.working_dir = repo_path
        
        # Mettre √† jour
        success, _ = self.run_command("git pull")
        self.print_success("D√©p√¥t pr√©par√©")
        return True
    
    def create_branch(self):
        """Cr√©er une nouvelle branche"""
        self.print_step(f"Cr√©ation de la branche {self.branch_name}...")
        
        success, _ = self.run_command(f"git checkout -b {self.branch_name}")
        if success:
            self.print_success("Branche cr√©√©e")
            return True
        return False
    
    def make_changes(self):
        """Effectuer des modifications dans le d√©p√¥t"""
        self.print_step("Modification des fichiers...")
        
        # Cr√©er ou modifier un fichier
        readme_path = os.path.join(self.working_dir, "README.md")
        collab_file = os.path.join(self.working_dir, "COLLABORATION.md")
        
        if os.path.exists(readme_path):
            # Ajouter √† README existant
            with open(readme_path, 'a', encoding='utf-8') as f:
                f.write(f"\n\n<!-- Collaboration update {datetime.now().isoformat()} -->\n")
                f.write("ü§ù **Pair Programming**: Contributing to open source with collaboration\n")
            self.print_success("README.md modifi√©")
        else:
            # Cr√©er un nouveau fichier de collaboration
            content = f"""# Collaboration Update

Date: {datetime.now().isoformat()}
Auteurs: {self.user_name} et {self.collaborator_name}

## Objectif
D√©monstration de collaboration pour le badge Pair Extraordinaire

## Modifications
- Ajout de documentation collaborative
- Mise √† jour des m√©tadonn√©es du projet
- D√©monstration des pratiques de pair programming

## M√©tadonn√©es
- Repository: {self.repo_owner}/{self.repo_name}
- Branch: {self.branch_name}
- Automation: Python Script

---
*G√©n√©r√© automatiquement par le script d'automatisation GitHub Pair Badge*
"""
            with open(collab_file, 'w', encoding='utf-8') as f:
                f.write(content)
            self.print_success("Fichier COLLABORATION.md cr√©√©")
        
        return True
    
    def create_collaborative_commit(self):
        """Cr√©er un commit avec co-auteurs"""
        self.print_step("Cr√©ation du commit collaboratif...")
        
        # Ajouter les fichiers
        success, _ = self.run_command("git add .")
        if not success:
            return False
        
        # Cr√©er le commit avec co-auteurs
        commit_message = f"""feat: Add collaborative documentation for Pair Extraordinaire

This commit demonstrates pair programming practices and collaborative 
development workflows for the GitHub Pair Extraordinaire achievement.

Features:
- Collaborative documentation
- Pair programming demonstration
- Multi-author contribution

Co-authored-by: {self.collaborator_name} <{self.collaborator_email}>
Co-authored-by: {self.user_name} <{self.user_email}>"""

        success, _ = self.run_command(f'git commit -m "{commit_message}"')
        if success:
            self.print_success("Commit collaboratif cr√©√©")
            return True
        return False
    
    def push_changes(self):
        """Pousser les modifications"""
        self.print_step("Push des modifications...")
        
        success, _ = self.run_command(f"git push origin {self.branch_name}")
        if success:
            self.print_success("Modifications pouss√©es")
            return True
        return False
    
    def create_pull_request_api(self):
        """Cr√©er une pull request via l'API GitHub"""
        if not self.github_token:
            self.print_warning("Token GitHub manquant, cr√©ation manuelle n√©cessaire")
            return self.create_pull_request_manual()
        
        self.print_step("Cr√©ation de la Pull Request via API...")
        
        url = f"https://api.github.com/repos/{self.repo_owner}/{self.repo_name}/pulls"
        headers = {
            "Authorization": f"token {self.github_token}",
            "Accept": "application/vnd.github.v3+json"
        }
        
        data = {
            "title": "feat: Add collaborative documentation for Pair Extraordinaire badge",
            "head": self.branch_name,
            "base": "main",
            "body": f"""# Collaborative Development Demonstration

This PR showcases collaborative development practices for the GitHub Pair Extraordinaire achievement.

## Changes
- Added collaborative documentation
- Updated project metadata
- Demonstrated pair programming workflows

## Co-authors
- {self.collaborator_name}
- {self.user_name}

## Automation
This PR was created automatically using the GitHub Pair Badge automation script.

## Achievement Goal
This commit demonstrates multi-author collaboration for the **Pair Extraordinaire** badge.

---
*Generated automatically on {datetime.now().isoformat()}*
"""
        }
        
        try:
            response = requests.post(url, headers=headers, json=data)
            if response.status_code == 201:
                pr_data = response.json()
                pr_number = pr_data['number']
                pr_url = pr_data['html_url']
                self.print_success(f"Pull Request cr√©√©e: #{pr_number}")
                print(f"URL: {pr_url}")
                
                # Optionnel: merger automatiquement
                if input("Merger automatiquement la PR? (y/n): ").lower() == 'y':
                    self.merge_pull_request_api(pr_number)
                
                return True
            else:
                self.print_error(f"√âchec cr√©ation PR: {response.status_code}")
                return False
        except Exception as e:
            self.print_error(f"Erreur API: {str(e)}")
            return False
    
    def merge_pull_request_api(self, pr_number):
        """Merger une pull request via l'API"""
        self.print_step(f"Merge de la PR #{pr_number}...")
        
        url = f"https://api.github.com/repos/{self.repo_owner}/{self.repo_name}/pulls/{pr_number}/merge"
        headers = {
            "Authorization": f"token {self.github_token}",
            "Accept": "application/vnd.github.v3+json"
        }
        
        data = {
            "commit_title": "feat: Add collaborative documentation",
            "commit_message": "Merge collaborative development demonstration",
            "merge_method": "squash"
        }
        
        try:
            response = requests.put(url, headers=headers, json=data)
            if response.status_code == 200:
                self.print_success("Pull Request merg√©e avec succ√®s")
                
                # Supprimer la branche
                self.delete_branch_api()
                return True
            else:
                self.print_error(f"√âchec merge: {response.status_code}")
                return False
        except Exception as e:
            self.print_error(f"Erreur merge: {str(e)}")
            return False
    
    def delete_branch_api(self):
        """Supprimer la branche via l'API"""
        url = f"https://api.github.com/repos/{self.repo_owner}/{self.repo_name}/git/refs/heads/{self.branch_name}"
        headers = {
            "Authorization": f"token {self.github_token}",
            "Accept": "application/vnd.github.v3+json"
        }
        
        try:
            response = requests.delete(url, headers=headers)
            if response.status_code == 204:
                self.print_success("Branche supprim√©e")
            else:
                self.print_warning("Impossible de supprimer la branche automatiquement")
        except Exception as e:
            self.print_warning(f"Erreur suppression branche: {str(e)}")
    
    def create_pull_request_manual(self):
        """Instructions pour cr√©ation manuelle de PR"""
        self.print_step("Instructions pour cr√©ation manuelle...")
        
        print("\n=== CR√âATION MANUELLE DE PULL REQUEST ===")
        print(f"1. Allez sur: https://github.com/{self.repo_owner}/{self.repo_name}")
        print("2. Cliquez sur 'Compare & pull request'")
        print("3. Titre: 'feat: Add collaborative documentation for Pair Extraordinaire badge'")
        print("4. Description: Mentionnez la collaboration et les co-auteurs")
        print("5. Cr√©ez la pull request")
        print("6. Mergez avec 'Squash and merge'")
        print("7. Supprimez la branche apr√®s merge")
        print()
        
        return True
    
    def cleanup(self):
        """Nettoyer les fichiers temporaires"""
        if hasattr(self, 'working_dir') and os.path.exists(self.working_dir):
            shutil.rmtree(os.path.dirname(self.working_dir))
            self.print_success("Nettoyage termin√©")
    
    def final_check(self):
        """V√©rification finale et instructions"""
        self.print_step("V√©rification finale...")
        
        print("\n=== R√âSUM√â ===")
        print(f"‚úÖ D√©p√¥t: {self.repo_owner}/{self.repo_name}")
        print(f"‚úÖ Branche: {self.branch_name}")
        print("‚úÖ Commit collaboratif cr√©√©")
        print("‚úÖ Modifications pouss√©es")
        print()
        
        self.print_success("Processus termin√©!")
        self.print_warning("Le badge peut prendre quelques minutes √† appara√Ætre.")
        
        print("\n=== V√âRIFICATION ===")
        print("1. V√©rifiez que votre commit montre 2 avatars d'utilisateurs")
        print("2. Allez sur votre profil GitHub pour voir le badge")
        print("3. Le badge 'Pair Extraordinaire' devrait appara√Ætre dans vos achievements")
        print(f"4. Lien direct: https://github.com/{self.user_name}")
    
    def run(self):
        """Ex√©cuter le processus complet"""
        print("\033[32m")
        print("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
        print("‚ïë             GITHUB PAIR EXTRAORDINAIRE AUTOMATION           ‚ïë")
        print("‚ïë                Script Python automatis√©                     ‚ïë")
        print("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
        print("\033[0m\n")
        
        try:
            self.setup_config()
            
            if not self.prepare_repo():
                return False
                
            if not self.create_branch():
                return False
                
            if not self.make_changes():
                return False
                
            if not self.create_collaborative_commit():
                return False
                
            if not self.push_changes():
                return False
                
            self.create_pull_request_api()
            self.final_check()
            
            self.print_success("üéâ Automatisation termin√©e avec succ√®s!")
            return True
            
        except KeyboardInterrupt:
            self.print_error("Script interrompu par l'utilisateur")
            return False
        except Exception as e:
            self.print_error(f"Erreur inattendue: {str(e)}")
            return False
        finally:
            self.cleanup()

def main():
    """Point d'entr√©e principal"""
    automator = GitHubPairBadgeAutomator()
    success = automator.run()
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main() 